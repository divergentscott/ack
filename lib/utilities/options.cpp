#include "options.h"
#include <boost/filesystem.hpp>

namespace d3d {

po::options_description IOOptions::getCommandLine() {
    po::options_description base("I/O options");
    // clang-format off
    base.add_options()
    ("help,h", "Produce help message.")
	("input,i", po::value<std::string>(&input),
        "filename with .stl or .bdf extension")
    ("output,o", po::value<std::string>(&outputPath),
        "Path of output file (format will be "
        "determined by extension).")
	("outputFolder",
        po::value<std::string>(&outputFolder),
        "Folder for all generated output files (alternative"
     " to output option).")
	("verb", po::value<int>(&verboseLevel),
        "verbose level (1 - 10 with 1 min verbal)")
	("version", "display the version string");
    // clang-format on

    return base;
}

po::options_description HealingOptions::getCommandLine() {
    po::options_description healing("Healing options");
    // clang-format off
    healing.add_options()
    ("remeshIntersections",
        po::value<bool>(&remesh_intersections),
        "Remesh regions containing self-intersections before "
        "the remaining healing procedure.")
    ("removeNoiseShells", po::value<bool>(&remove_noise_shells),
        "Detect disconnected small meshes and remove them.")
    ("makeManifold", po::value<bool>(&make_manifold),
        "Check if the solid is manifold, and make it manifold if "
		"it is not.")
    ("makeClosed", po::value<bool>(&make_closed),
        "Check closure of solid, close it if it is found to be open.")
    ("fixOrientations", po::value<bool>(&fix_orientation),
        "Make orientations of all face normals consistent.")
    ("fixIntersections", po::value<bool>(&fix_intersections),
         "Fix self-intersections in mesh.");
    // clang-format on

    return healing;
}

po::options_description OffsetOptions::getCommandLine() {
    po::options_description offset("Offset options");
    // clang-format off
    offset.add_options()
    ("offset", po::value<float>(&offsetValue)->implicit_value(0.0),
        "Constant offset value")
    ("voxel", po::value<float>(&voxelSize)->default_value(1.0),
        "Voxel size for offset")
    ("offsetFile,f", po::value<std::string>(&offsetFile)->default_value(""),
        "file containing offset field");
    // clang-format on

    return offset;
}

po::options_description TetraOptions::getCommandLine() {
    po::options_description tetras("Tetra options");
    // clang-format off
    tetras.add_options()
    ("tets", po::value<double>(&mquality)->implicit_value(1.2),
        "Generate a tetra mesh, optionally with a quality parameter (default = "
        "1.2)")
    ("tetVolumeBound", po::value<double>(&volumeBound)->implicit_value(-1.0),
        "Upper bound for the volume of tetrahedral elements generated by "
        "tetgen.")
    ("tetOptimizationLevel",
        po::value<int>(&optimizationLevel)->implicit_value(2),
        "Tetgen mesh optimzation level is an integer 0 to 9, where 0 means no "
        "mesh optimization is executed. The larger the level is, the more mesh "
        "optimization iterations will be performed, and TetGen may run very "
        "slow. Default mesh optimization level is 2.")
    ("tetsOnly", "Generate tetrahedral mesh without smoothing, repairing or "
        "remeshing\n");
    // clang-format on

    return tetras;
}
std::istream& operator>>(std::istream& in, Smoother& smoothingMethod) {
    std::string smoothMethodStr;
    in >> smoothMethodStr;
    std::transform(smoothMethodStr.begin(), smoothMethodStr.end(),
                   smoothMethodStr.begin(), ::tolower);
    if (smoothMethodStr == "laplacian")
        smoothingMethod = Smoother::Laplacian;
    else if (smoothMethodStr == "taubin")
        smoothingMethod = Smoother::Taubin;
    else if (smoothMethodStr == "bilaplacian")
        smoothingMethod = Smoother::Bilaplacian;
    else if (smoothMethodStr == "mcf")
        smoothingMethod = Smoother::MCF;
    else if (smoothMethodStr == "taubinmcf")
        smoothingMethod = Smoother::TaubinMCF;
    else if (smoothMethodStr == "bilaplacianmcf")
        smoothingMethod = Smoother::BilaplacianMCF;
    else if (smoothMethodStr == "membrane")
        smoothingMethod = Smoother::Membrane;
    else if (smoothMethodStr == "thinplate")
        smoothingMethod = Smoother::ThinPlate;
    else if (smoothMethodStr == "minimumvariation")
        smoothingMethod = Smoother::MinimumVariation;
    else if (smoothMethodStr == "hybrid")
        smoothingMethod = Smoother::Hybrid;
    else if (smoothMethodStr == "repair")
        smoothingMethod = Smoother::Repair;
    else
        in.setstate(std::ios_base::failbit);

    return in;
}

std::ostream& operator<<(std::ostream& out, const Smoother& smoothingMethod) {
    if (smoothingMethod == Smoother::Laplacian) out << "Laplacian";
    if (smoothingMethod == Smoother::Taubin) out << "Taubin";
    if (smoothingMethod == Smoother::Bilaplacian) out << "Bilaplacian";
    if (smoothingMethod == Smoother::MCF) out << "MCF";
    if (smoothingMethod == Smoother::TaubinMCF) out << "TaubinMCF";
    if (smoothingMethod == Smoother::BilaplacianMCF) out << "BilaplacianMCF";
    if (smoothingMethod == Smoother::Membrane) out << "membrane";
    if (smoothingMethod == Smoother::ThinPlate) out << "thin plate";
    if (smoothingMethod == Smoother::MinimumVariation)
        out << "minimum variation";
    if (smoothingMethod == Smoother::Hybrid) out << "hybrid";
    if (smoothingMethod == Smoother::Repair) out << "repair";
    return out;
}

std::istream& operator>>(std::istream& in, FreezeConstraints& freezeMethod) {
    std::string str;
    in >> str;
    std::transform(str.begin(), str.end(), str.begin(), ::tolower);
    if (str == "markednodesfem")
        freezeMethod = d3d::FreezeConstraints::SubsetNodesFEM;
    else if (str == "isosurfacedistances")
        freezeMethod = d3d::FreezeConstraints::IsosurfaceDistances;
    else if (str == "byeuclideandistance")
        freezeMethod = d3d::FreezeConstraints::ByEuclideanDistance;
    else if (str == "nondesignpid")
        freezeMethod = d3d::FreezeConstraints::NonDesignPID;
    else if (str == "markednodestxt")
        freezeMethod = d3d::FreezeConstraints::MarkedNodesTxt;
    else if (str == "nondesigninterface")
        freezeMethod = d3d::FreezeConstraints::NonDesignInterface;
    else if (str == "freezeandmerge")
        freezeMethod = d3d::FreezeConstraints::FreezeAndMerge;
    else
        in.setstate(std::ios_base::failbit);

    return in;
}
std::ostream& operator<<(std::ostream& out,
                         const FreezeConstraints& freezeMethod) {
    if (freezeMethod == FreezeConstraints::SubsetNodesFEM)
        out << "subset of nodes of FEM file";
    if (freezeMethod == FreezeConstraints::IsosurfaceDistances)
        out << "isosurface distances";
    if (freezeMethod == FreezeConstraints::ByEuclideanDistance)
        out << "by Euclidean distance";
    if (freezeMethod == FreezeConstraints::NonDesignPID)
        out << "non design PID";
    if (freezeMethod == FreezeConstraints::MarkedNodesTxt)
        out << "marked nodes txt";
    if (freezeMethod == FreezeConstraints::NonDesignInterface)
        out << "non design interace";
    if (freezeMethod == FreezeConstraints::FreezeAndMerge)
        out << "freeze and merge";
    return out;
}

po::options_description SmoothOptions::getCommandLine() {
    po::options_description smooth("Smooth options");
    // clang-format off
    smooth.add_options()
	("smooth,s", po::value<int>(&nstep)->default_value(4)->implicit_value(4),
        "number of smoothing iterations (set to 0 to disable smoothing)")
    ("msize", po::value<double>(&msize), "desired element size in mm")
    ("msizescale", po::value<double>(&msizescale)->default_value(1.1),
        "desired element size scale.This scale factor will be multiplied to "
        "the average edge size to generate element mesh size")
    ("smoothMethod",
        po::value<Smoother>(&smoothMethod)->default_value(Smoother::Laplacian),
        "arg = laplacian (default), taubin, bilaplacian, taubin, mcf, "
        "taubinmcf, bilaplacianmcf, thinplate, hybrid, minimumvariation")
    ("allowIntersections",
        "Do not check intersection and prevent generating intersections")
	("freezeMethod", po::value<FreezeConstraints>(&constraints.freezeMethod),
        "arg = NonDesignPID, IsosurfaceDistances, ByEuclideanDistance,  "
        "MarkedNodesTxt, MarkedNodesFEM, NonDesignInterface, FreezeAndMerge")
    ("freezeFile", po::value<std::string>(&constraints.freezeFile),
        "arg = file containing the additional mesh for the freeze method "
        "( ByEuclideanDistance"
        "MarkedNodesTxt, MarkedNodesFEM, NonDesignInterface, FreezeAndMerge)")
    ("freezePID\n", po::value<int>(&constraints.freezePID)->default_value(0),
        "PID of the nodes to freeze (PID of non design space, works as well "
        "with a freezeFile)")
	("disableShrinkPatch", po::value<bool>(&constraints.disableShrinkPatch)->default_value(false),
         "Set to true to retain the full constraints instead of shrinking them.");
    // clang-format on
    return smooth;
}

po::options_description IsosurfaceOptions::getCommandLine() {
    po::options_description isosurface("Isosurface options");
    // clang-format off
    isosurface.add_options()
    ("isosurface", po::value<std::string>(&level),
        "arg = threshold. Extract isosurface for given threshold "
        "[densityfield required, input must be fem file]")
    ("densityField", po::value<std::string>(&densityField),
        "cell based density field with .csv or .sh "
        "extension\n")  // to deprecate in favor of the
                        // following
    ("cellDensityField", po::value<std::string>(&densityField),
         "cell based density field with .csv or .sh extension\n")
    ("nodeDensityField", po::value<std::string>(&densityField),
         "node based density field with .csv or .sh extension\n")
    ("close",
         po::value<bool>(&makeClosedIsosurface)->default_value(true),
         "Close isosurface (default:true)")
    ("heal", po::value<bool>(&heal)->default_value(false),
         "Heal isosurface (default:false): fix self-intersections, make "
         "manifold, close solid and make cell orientations consistent."
         "If set to true, the pids are not persistent.")
    ("nonDesign", po::value<std::string>(&nonDesignHandling), "Non design"
         " handling (without, fused, separate)");
    // clang-format on
    return isosurface;
}

po::options_description RemeshOptions::getCommandLine() {
    po::options_description remesh("Remesh options");
    // clang-format off
    remesh.add_options()
    ("msize", po::value<double>(&msize),
        "desired element size in mm")
    ("msizescale", po::value<double>(&msizescale),
        "desired element size scale.This scale factor will be multiplied to "
        "the average edge size to generate element mesh size")
    ("msizescale_min", po::value<double>(&msizescale_min),
        "This scale factor will be multiplied to the element mesh size to "
        "generate min element mesh size")
    ("msizescale_max", po::value<double>(&msizescale_max),
        "This scale factor will be multiplied to the element mesh size to "
        "generate max element mesh size")
    ("freezeMethod", po::value<FreezeConstraints>(&constraints.freezeMethod),
        "arg = NonDesignPID, IsosurfaceDistances, ByEuclideanDistance,  "
        "MarkedNodesTxt, MarkedNodesFEM, NonDesignInterface, FreezeAndMerge")
    ("freezeFile", po::value<std::string>(&constraints.freezeFile),
        "arg = file containing the additional mesh for the freeze method "
        "(ByEuclideanDistance"
        "MarkedNodesTxt, MarkedNodesFEM, NonDesignInterface, FreezeAndMerge)")
    ("freezePID\n", po::value<int>(&constraints.freezePID)->default_value(0),
        "PID of the nodes to freeze (PID of non design space, works as well "
        "with a freezeFile)")
	("disableShrinkPatch", po::value<bool>(&constraints.disableShrinkPatch)->default_value(false),
         "Set to true to retain the full constraints instead of shrinking them.");;
    // clang-format on
    return remesh;
}

po::options_description ThickerOptions::getCommandLine() {
    po::options_description thicker("Thicker options");
    // clang-format off
    thicker.add_options()
    ("bonethreshold",
        po::value<double>(&thinBoneThreshold)->default_value(5),
        "Thin bone threshold value in mm")
	("thickerIterations", po::value<int>(&nthickerIterations_)->default_value(1), 
		"Thicker will ietrate thickerIterations number of times")
    ("regionthreshold",
        po::value<double>(&thinRegionThreshold)->default_value(2),
        "Thin region threshold value in mm")
	("hausdroffStartTol",
po::value<double>(&hausdorffStartTol_)->default_value(0.1), "The remesh size control value")
    ("hausdroffFinalTol", po::value<double>(&hausdorffFinalTol_)->default_value(0.1), 
		"The remesh size control value")
    ("domodification", po::value<bool>(&doModification)->default_value(true),
        "Thin thin Bone/region values will be used to add constraints for "
        "smoothing")
	("docleanup", po::value<bool>(&doCleanUp)->default_value(true), "Thin thin Bone/region "
		"values will be used to add constraints for smoothing")
    ("remesh", po::value<bool>(&doRemeshing)->default_value(true),
          "Do remesh after thicker")
    ("doSmooth", po::value<bool>(&doSmoothing)->default_value(true),
            "Do smoothing after thicker");
    // clang-format on
    return thicker;
}

}  // namespace d3d
